2025-09-08 21:47:40,166 - INFO  - 
FUNCTION INITIALIZATION
2025-09-08 21:47:40,166 - INFO  - ========================================

2025-09-08 21:47:40,242 - INFO  - 初始待处理函数: ['main1', 'TripleAbsMaxFun']
2025-09-08 21:47:40,242 - INFO  - 现在处理函数 TripleAbsMaxFun

2025-09-08 21:47:40,249 - INFO  - 
GENERATE ANNOTATION FOR TripleAbsMaxFun
2025-09-08 21:47:40,249 - INFO  - ========================================

2025-09-08 21:47:40,249 - INFO  - 函数 TripleAbsMaxFun 已经初始化
2025-09-08 21:47:40,249 - INFO  - 开始生成 TripleAbsMaxFun 的注释代码
2025-09-08 21:47:40,259 - INFO  - 待插入模板的 ACSL TripleAbsMaxFun.c文件的内容为: 
typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;
/*@
    requires \valid(pIp);
    requires \valid(pIp->abs+(0..2)) ;
    requires \valid(pIp->ret);
    requires \separated(pIp, pIp->ret);
    */
    
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;


}
2025-09-08 21:47:40,260 - INFO  - 
GENERATE FUNCTION SPECIFICATION FOR TripleAbsMaxFun
2025-09-08 21:47:40,260 - INFO  - ========================================

2025-09-08 21:47:40,370 - INFO  - 开始生成完整的 TripleAbsMaxFun 的注释代码
2025-09-08 21:47:40,374 - INFO  - 开始生成 TripleAbsMaxFun 的 ACSL 规约
2025-09-08 21:47:40,375 - INFO  - content before specgen: 
typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;
/*@
    requires \valid(pIp);
    requires \valid(pIp->abs+(0..2)) ;
    requires \valid(pIp->ret);
    requires \separated(pIp, pIp->ret);
           ensures PLACE_HOLDER; 
    assigns PLACE_HOLDER;
    */
    
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;


}
2025-09-08 21:47:49,065 - INFO  - content after specgen: 

typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;

/*@
    requires \valid(pIp);                               // Pointer pIp must be valid
    requires \valid(pIp->abs+(0..2));                   // The abs array must have 3 valid elements
    requires \valid(pIp->ret);                          // Pointer ret must be valid
    requires \separated(pIp, pIp->ret);                 // pIp and pIp->ret must not overlap
    ensures pIp->tmax == \max(\abs(pIp->abs[0]), \abs(pIp->abs[1]), \abs(pIp->abs[2])); // tmax is the maximum absolute value
    ensures *(pIp->ret) == pIp->tmax;                   // The value pointed to by ret is updated to tmax
    assigns pIp->tmax, *(pIp->ret);                     // Function modifies tmax and the value pointed to by ret
*/
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;
}

2025-09-08 21:47:49,313 - INFO  - syntax Error
[kernel] Parsing output/pIp/TripleAbsMaxFun.c (with preprocessing)
[kernel:annot-error] output/pIp/TripleAbsMaxFun.c:14: Warning: 
  no such predicate or logic function \max(ℤ, ℤ, ℤ). Ignoring logic specification of function TripleAbsMaxFun
[kernel] User Error: warning annot-error treated as fatal error.
[kernel] Frama-C aborted: invalid user input.

2025-09-08 21:48:04,598 - INFO  - syntax Correct
2025-09-08 21:48:05,460 - INFO  - Loop Invariant:
2025-09-08 21:48:05,460 - INFO  - []
2025-09-08 21:48:05,460 - INFO  - 
2025-09-08 21:48:05,460 - INFO  - Assertion:
2025-09-08 21:48:05,460 - INFO  - [True, True, True, True, True, True, True]
2025-09-08 21:48:05,460 - INFO  - 
2025-09-08 21:48:05,461 - INFO  - Post Condition:
2025-09-08 21:48:05,461 - INFO  - [True, True]
2025-09-08 21:48:05,461 - INFO  - 
2025-09-08 21:48:05,461 - INFO  - Model生成的TripleAbsMaxFun.c 的规约的内容为
typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;

/*@
    requires \valid(pIp);                               // Pointer pIp must be valid
    requires \valid(pIp->abs+(0..2));                   // The abs array must have 3 valid elements
    requires \valid(pIp->ret);                          // Pointer ret must be valid
    requires \separated(pIp, pIp->ret);                 // pIp and pIp->ret must not overlap
    ensures pIp->tmax == \max(\max(\abs(pIp->abs[0]), \abs(pIp->abs[1])), \abs(pIp->abs[2])); // tmax is the maximum absolute value
    ensures *(pIp->ret) == pIp->tmax;                   // The value pointed to by ret is updated to tmax
    assigns pIp->tmax, *(pIp->ret);                     // Function modifies tmax and the value pointed to by ret
*/
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;
}

2025-09-08 21:48:05,461 - INFO  - 
GENERATE ANNOTATION FOR main1
2025-09-08 21:48:05,461 - INFO  - ========================================

2025-09-08 21:48:05,461 - INFO  - 函数 main1 已经初始化
2025-09-08 21:48:05,461 - INFO  - 开始生成 main1 的注释代码
2025-09-08 21:48:05,474 - INFO  - 待插入模板的 ACSL main1.c文件的内容为: 



typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;

/*@
    requires \valid(pIp);                               // Pointer pIp must be valid
    requires \valid(pIp->abs+(0..2));                   // The abs array must have 3 valid elements
    requires \valid(pIp->ret);                          // Pointer ret must be valid
    requires \separated(pIp, pIp->ret);                 // pIp and pIp->ret must not overlap
    ensures pIp->tmax == \max(\max(\abs(pIp->abs[0]), \abs(pIp->abs[1])), \abs(pIp->abs[2])); // tmax is the maximum absolute value
    ensures *(pIp->ret) == pIp->tmax;                   // The value pointed to by ret is updated to tmax
    assigns pIp->tmax, *(pIp->ret);                     // Function modifies tmax and the value pointed to by ret
*/
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;
}
/*@
    requires \valid(pIp);
requires \valid(pIp->abs+(0..2));
requires \valid(pIp->ret);
requires \separated(pIp, pIp->ret);
    */
    
void main1(TripleAbsMax *pIp)
{

	pIp -> abs[0] = 1;
	pIp -> abs[1] = 2;
	pIp -> abs[2] = -3;

	TripleAbsMaxFun(pIp);

    /*@ assert pIp -> tmax == 3; */
}
2025-09-08 21:48:05,480 - INFO  - 
GENERATE FUNCTION SPECIFICATION FOR main1
2025-09-08 21:48:05,480 - INFO  - ========================================

2025-09-08 21:48:05,509 - INFO  - 开始生成 main1 的 ACSL 规约
2025-09-08 21:48:05,509 - INFO  - content before specgen: 



typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;

/*@
    requires \valid(pIp);                               // Pointer pIp must be valid
    requires \valid(pIp->abs+(0..2));                   // The abs array must have 3 valid elements
    requires \valid(pIp->ret);                          // Pointer ret must be valid
    requires \separated(pIp, pIp->ret);                 // pIp and pIp->ret must not overlap
    ensures pIp->tmax == \max(\max(\abs(pIp->abs[0]), \abs(pIp->abs[1])), \abs(pIp->abs[2])); // tmax is the maximum absolute value
    ensures *(pIp->ret) == pIp->tmax;                   // The value pointed to by ret is updated to tmax
    assigns pIp->tmax, *(pIp->ret);                     // Function modifies tmax and the value pointed to by ret
*/
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;
}
/*@
    requires \valid(pIp);
requires \valid(pIp->abs+(0..2));
requires \valid(pIp->ret);
requires \separated(pIp, pIp->ret);
    */
    
void main1(TripleAbsMax *pIp)
{

	pIp -> abs[0] = 1;
	pIp -> abs[1] = 2;
	pIp -> abs[2] = -3;

	TripleAbsMaxFun(pIp);

    /*@ assert pIp -> tmax == 3; */
}
2025-09-08 21:48:05,509 - INFO  - content after specgen: 



typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;

/*@
    requires \valid(pIp);                               // Pointer pIp must be valid
    requires \valid(pIp->abs+(0..2));                   // The abs array must have 3 valid elements
    requires \valid(pIp->ret);                          // Pointer ret must be valid
    requires \separated(pIp, pIp->ret);                 // pIp and pIp->ret must not overlap
    ensures pIp->tmax == \max(\max(\abs(pIp->abs[0]), \abs(pIp->abs[1])), \abs(pIp->abs[2])); // tmax is the maximum absolute value
    ensures *(pIp->ret) == pIp->tmax;                   // The value pointed to by ret is updated to tmax
    assigns pIp->tmax, *(pIp->ret);                     // Function modifies tmax and the value pointed to by ret
*/
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;
}
/*@
    requires \valid(pIp);
requires \valid(pIp->abs+(0..2));
requires \valid(pIp->ret);
requires \separated(pIp, pIp->ret);
    */
    
void main1(TripleAbsMax *pIp)
{

	pIp -> abs[0] = 1;
	pIp -> abs[1] = 2;
	pIp -> abs[2] = -3;

	TripleAbsMaxFun(pIp);

    /*@ assert pIp -> tmax == 3; */
}
2025-09-08 21:48:09,764 - INFO  - syntax Correct
2025-09-08 21:48:10,999 - INFO  - Loop Invariant:
2025-09-08 21:48:11,000 - INFO  - []
2025-09-08 21:48:11,000 - INFO  - 
2025-09-08 21:48:11,000 - INFO  - Assertion:
2025-09-08 21:48:11,000 - INFO  - [True, True, True, True, True, True, True, True]
2025-09-08 21:48:11,000 - INFO  - 
2025-09-08 21:48:11,000 - INFO  - Post Condition:
2025-09-08 21:48:11,000 - INFO  - [True, True]
2025-09-08 21:48:11,000 - INFO  - 
2025-09-08 21:48:11,000 - INFO  - Model生成的main1.c 的规约的内容为


typedef struct __TripleAbsMax
{
    int abs[3];
    int tmax;
    int* ret;
} TripleAbsMax;

/*@
    requires \valid(pIp);                               // Pointer pIp must be valid
    requires \valid(pIp->abs+(0..2));                   // The abs array must have 3 valid elements
    requires \valid(pIp->ret);                          // Pointer ret must be valid
    requires \separated(pIp, pIp->ret);                 // pIp and pIp->ret must not overlap
    ensures pIp->tmax == \max(\max(\abs(pIp->abs[0]), \abs(pIp->abs[1])), \abs(pIp->abs[2])); // tmax is the maximum absolute value
    ensures *(pIp->ret) == pIp->tmax;                   // The value pointed to by ret is updated to tmax
    assigns pIp->tmax, *(pIp->ret);                     // Function modifies tmax and the value pointed to by ret
*/
void TripleAbsMaxFun(TripleAbsMax *pIp)
{
    int absfx1 = pIp->abs[0];
    int absfy2 = pIp->abs[1];
    int absfz3 = pIp->abs[2];

    if (pIp->abs[0] < 0)
    {
        absfx1 = -pIp->abs[0];
    }

    if (pIp->abs[1] < 0)
    {
        absfy2 = -pIp->abs[1];
    }

    if (pIp->abs[2] < 0)
    {
        absfz3 = -pIp->abs[2];
    }

    if (absfx1 > absfy2)
    {
        pIp->tmax = absfx1;
    }
    else
    {
        pIp->tmax = absfy2;
    }

    if (absfz3 > pIp->tmax)
    {
        pIp->tmax = absfz3;
    }

    *(pIp->ret) = pIp->tmax;
}
/*@
    requires \valid(pIp);
requires \valid(pIp->abs+(0..2));
requires \valid(pIp->ret);
requires \separated(pIp, pIp->ret);
    */
    
void main1(TripleAbsMax *pIp)
{

	pIp -> abs[0] = 1;
	pIp -> abs[1] = 2;
	pIp -> abs[2] = -3;

	TripleAbsMaxFun(pIp);

    /*@ assert pIp -> tmax == 3; */
}
2025-09-08 21:48:11,002 - INFO  - 
SPECIFICATION FOR main1
2025-09-08 21:48:11,002 - INFO  - ========================================

2025-09-08 21:48:11,002 - INFO  - 
函数 main1 的 VST Specification 为:
/*@
With pIp_abs_l pIp_tmax pIp_ret_v pIp_ret
Require store_int_array(pIp->abs,3, pIp_abs_l) && pIp->tmax == pIp_tmax && *(pIp->ret) == pIp_ret_v && (pIp->ret) == pIp_ret
Ensure emp
*/
2025-09-08 21:48:11,002 - INFO  - 
函数 main1 的 ACSL Specification 为:

2025-09-08 21:48:11,213 - INFO  - 
VERIFICATION FOR main1
2025-09-08 21:48:11,213 - INFO  - ========================================

2025-09-08 21:48:15,459 - INFO  - syntax Correct
2025-09-08 21:48:16,711 - INFO  - Loop Invariant:
2025-09-08 21:48:16,711 - INFO  - []
2025-09-08 21:48:16,711 - INFO  - 
2025-09-08 21:48:16,711 - INFO  - Assertion:
2025-09-08 21:48:16,711 - INFO  - [True, True, True, True, True, True, True, True]
2025-09-08 21:48:16,711 - INFO  - 
2025-09-08 21:48:16,711 - INFO  - Post Condition:
2025-09-08 21:48:16,711 - INFO  - [True, True]
2025-09-08 21:48:16,712 - INFO  - 
2025-09-08 21:48:16,712 - INFO  - ========================================
2025-09-08 21:48:16,712 - INFO  - first_pass:
2025-09-08 21:48:16,712 - INFO  - syntax=1, valid=1,satisfy=1
2025-09-08 21:48:16,712 - INFO  - ========================================
