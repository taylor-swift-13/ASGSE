[
    {
        "name": "array_sum",
        "category": "loop invariant",
        "type": "array",
        "input": "\n/*@\nPLACE_HOLDER_PREDICATE_OR_LOGIC_FUNCTION\n*/\n\n/*@\nrequires \\valid(array + (0 .. n-1));\nrequires n >= 0;\n*/\nint array_sum(int* array, int n) {\n    int total = 0;\n    int i = 0;\n\n    /* >>> LOOP INVARIANT TO FILL <<< */\n\n    /*@ \n    loop invariant PLACE_HOLDER_i;\n    loop invariant PLACE_HOLDER_total;\n    loop assigns PLACE_HOLDER_ASSIGNMENTS;\n    */\n    while (i < n) {\n        total += array[i];\n        i++;\n    }\n    \n    return total;\n}\n",
        "output": "\n/*@\n  logic integer sum(int* array, integer begin, integer end) =\n    end <= begin ? 0 : sum(array,begin, end - 1) + array[end - 1];\n*/\n\n/*@ requires \\valid(array + (0 .. n-1));\n    requires n >= 0;\n    ensures \\result == sum(array, 0, n);\n*/\nint array_sum(int* array, int n) {\n    int total = 0;\n    int i = 0;\n    \n    /*@ loop invariant 0 <= i <= n;\n        loop invariant total == sum(array, 0, i);\n        loop assigns total, i;\n    */\n    while (i < n) {\n        total += array[i];\n        i++;\n    }\n    \n    return total;\n}\n",
        "value": "This code snippet is a C function that calculates the sum of the elements in an array, with annotations written in a formal specification language (likely ACSL, used with tools like Frama-C). The annotations are used to specify preconditions, postconditions, and loop invariants, which help verify the correctness of the code using formal methods. Here's a breakdown of what the code does:\n\n### Code Explanation\n\n1. **Function Purpose**:\n   - The function `array_sum` takes two arguments: a pointer to an integer array (`array`) and the size of the array (`n`).\n   - It computes and returns the sum of the first `n` elements in the array.\n\n2. **Preconditions**:\n   - The `requires` annotations specify the conditions that must be true before the function is executed:\n     - `\\valid(array + (0 .. n-1))`: Ensures that the memory region corresponding to `array[0]` to `array[n-1]` is valid (i.e., accessible and not out of bounds).\n     - `n >= 0`: Ensures that the size of the array (`n`) is non-negative.\n\n3. **Initialization**:\n   - The variable `total` is initialized to `0` to store the sum of the array elements.\n   - The variable `i` is initialized to `0` to act as the loop index.\n\n4. **Loop**:\n   - The `while` loop iterates over the array from index `0` to `n-1` (inclusive).\n   - Inside the loop:\n     - `total` is updated by adding the value of the current array element (`array[i]`).\n     - `i` is incremented to move to the next element.\n\n5. **Loop Invariants**:\n   - The `loop invariant` annotations are placeholders (`PLACE_HOLDER_*`) where specific invariants should be defined. Loop invariants are properties that remain true at the start and end of each loop iteration, and they help prove the correctness of the loop.\n     - `PLACE_HOLDER_i`: Likely represents a condition about the loop index `i` (e.g., `0 <= i <= n`).\n     - `PLACE_HOLDER_total`: Likely represents a condition about the value of `total` (e.g., `total` is the sum of the first `i` elements of the array).\n     - `PLACE_HOLDER_ASSIGNMENTS`: Specifies which variables are modified by the loop (e.g., `i` and `total`).\n\n6. **Postconditions**:\n   - After the loop completes, the function returns the value of `total`, which is the sum of the first `n` elements of the array.\n\n### Formal Verification Purpose\nThe annotations (e.g., `requires`, `loop invariant`, `loop assigns`) are used for formal verification tools to ensure:\n- The function does not access invalid memory.\n- The loop behaves correctly and terminates.\n- The function produces the correct output based on the input and adheres to its specification.\n\n### Missing Components\n- The placeholders (`PLACE_HOLDER_*`) need to be replaced with actual logical expressions or invariants that describe the behavior of the loop and function. For example:\n  - `PLACE_HOLDER_i` could be `0 <= i <= n`.\n  - `PLACE_HOLDER_total` could be `total == \\sum(array[0 .. i-1])`.\n  - `PLACE_HOLDER_ASSIGNMENTS` could be `{i, total}`.\n\nOnce these placeholders are filled, the code can be formally verified for correctness.",
        "explanation": "\nThe `integer sum(int* array, integer begin, integer end)` function precisely calculates the total of array elements within a left-closed, right-open interval: array[begin] is included, while array[end] is excluded. The ensures \\result == sum(array, 0, n); clause formally states that the function's return value (\\result) must equal the mathematically defined sum of array from index 0 to n-1\n"
    },
    {
        "name": "list_append",
        "category": "loop invariant",
        "type": "list",
        "input": "\n#include <stdlib.h>\n\nstruct list {\n  struct list *tail;\n};\n\n/*@\nPLACE_HOLDER_PREDICATE_OR_LOGIC_FUNCTION\n*/\n\n/*@\nrequires PLACE_HOLDER;\nensures PLACE_HOLDER;\n*/\nstruct list * append(struct list *x, struct list *y) {\n  struct list *t, *u;\n\n  if (x == NULL) {\n    return y;\n  } else {\n    t = x;\n    u = t->tail;\n\n    /*>>> LOOP INVARIANT TO FILL <<< */\n\n    /*@\n      PLACE_HOLDER_LOOP         \n    */\n    while (u != NULL) {\n      t = u;\n      u = t->tail;\n    }\n    t->tail = y;\n    return x;\n  }\n}\n",
        "output": "\n#include <stdlib.h>\n\nstruct list {\n  struct list *tail;\n};\n\n/*@\n  predicate lseg{L}(struct list* x, struct list* y) =\n    x == y || (x != y && \\valid(x) && \\separated(x, y) && lseg{L}(x->tail, y));\n*/\n\n/*@\n  predicate listrep(struct list* head) = lseg(head, NULL);\n*/\n\n/*@\npredicate disjoint(struct list* x, struct list* y) =\n    \\separated(x, y) &&\n    \\forall struct list* p, struct list* q;\n      lseg(x,p) && lseg(y,q) ==> \\separated(p,q);\n*/\n\n/*@\n  requires listrep(x) && listrep(y);\n  requires disjoint(x, y);\n  ensures listrep(\\result);\n*/\nstruct list * append(struct list *x, struct list *y) {\n  struct list *t, *u;\n\n  if (x == NULL) {\n    return y;\n  } else {\n    t = x;\n    u = t->tail;\n\n    /*@\n      loop invariant u == t->tail;\n      loop invariant listrep(t);          \n      loop invariant listrep(u);            \n      loop invariant listrep(y);     \n      loop invariant lseg(x, t);           \n    */\n    while (u != NULL) {\n      t = u;\n      u = t->tail;\n    }\n    t->tail = y;\n    return x;\n  }\n}\n\n",
        "value": "This C code defines a function to append one linked list to another. Let's break it down:\n\n1. **Struct Definition**:\n   - A `struct list` is defined, which represents a node in a singly linked list. Each node has a pointer `tail` that points to the next node in the list.\n\n2. **Function `append`**:\n   - This function takes two arguments, `x` and `y`, which are pointers to the head nodes of two linked lists.\n   - The purpose of this function is to append list `y` to the end of list `x`.\n\n3. **Function Logic**:\n   - If `x` is `NULL`, the function returns `y`. This means if the first list is empty, the result is simply the second list.\n   - If `x` is not `NULL`, it initializes two pointers, `t` and `u`, to traverse the list:\n     - `t` starts at the head of list `x`.\n     - `u` is initialized to the `tail` of `t` (i.e., the second node in list `x`).\n   - The function enters a `while` loop that continues until `u` is `NULL`. This loop traverses the list `x` until it reaches the last node.\n     - Inside the loop, `t` is updated to `u` (the current node), and `u` is updated to `t->tail` (the next node).\n   - After the loop, `t` points to the last node of list `x`. The `tail` of this last node is set to `y`, effectively appending list `y` to the end of list `x`.\n   - The function returns `x`, which is now the head of the combined list.\n\n4. **Annotations**:\n   - The code contains placeholders for formal specifications (using annotations) such as preconditions, postconditions, and loop invariants. These are indicated by `PLACE_HOLDER_PREDICATE_OR_LOGIC_FUNCTION`, `PLACE_HOLDER`, and `PLACE_HOLDER_LOOP`.\n   - These placeholders suggest that the code is intended to be used with a formal verification tool, which would require specifying these conditions to prove the correctness of the function.\n\nIn summary, this function appends the second list to the end of the first list and returns the head of the modified list. The placeholders indicate that the code is meant to be formally verified, but the specific conditions are not provided.",
        "explanation": "The code provided is a C program that appends one linked list to another, with formal specifications using predicates for verification purposes. Let's explain why the preconditions, postconditions, and loop invariants are correct:\n\n### Predicates:\n\n1. **`lseg{L}(struct list* x, struct list* y)`**:\n   - This predicate defines a \"list segment\" from node `x` to node `y`.\n   - It states that `x` is either equal to `y` (the segment is empty) or `x` is a valid node, `x` and `y` are separated (not overlapping), and the segment continues from `x->tail` to `y`.\n   - This predicate is used to describe segments of a list.\n\n2. **`listrep(struct list* head)`**:\n   - This predicate uses `lseg` to describe a proper list that starts at `head` and ends at `NULL`.\n   - It essentially states that `head` is the start of a well-formed linked list.\n\n3. **`disjoint(struct list* x, struct list* y)`**:\n   - This predicate asserts that two lists `x` and `y` are disjoint, meaning they do not share any nodes.\n   - It uses `\\separated` to ensure that `x` and `y` do not overlap and ensures that any segment of `x` is separated from any segment of `y`.\n\n### Preconditions:\n\n- `requires listrep(x) && listrep(y);`:\n  - This precondition ensures that both `x` and `y` are well-formed linked lists.\n\n- `requires disjoint(x, y);`:\n  - This precondition ensures that the lists `x` and `y` do not share any nodes, preventing cycles or overlaps when appending.\n\n### Postconditions:\n\n- `ensures listrep(\\result);`:\n  - This postcondition ensures that the result of the `append` function is a well-formed linked list, which is necessary for correctness.\n\n### Loop Invariants:\n\n1. **`u == t->tail;`**:\n   - This invariant ensures that `u` always points to the node following `t`, maintaining the traversal logic.\n\n2. **`listrep(t);`**:\n   - This invariant ensures that the list starting from `t` is well-formed at every iteration of the loop.\n\n3. **`listrep(u);`**:\n   - This invariant ensures that the list starting from `u` is well-formed at every iteration of the loop.\n\n4. **`listrep(y);`**:\n   - This invariant ensures that the list `y` remains well-formed throughout the loop, as it is not modified until the end.\n\n5. **`lseg(x, t);`**:\n   - This invariant ensures that there is a valid list segment from `x` to `t`, confirming that the traversal is correctly following the list structure.\n\n### Conclusion:\n\nThe specifications are correct because they:\n\n- Ensure that the inputs are well-formed and disjoint, preventing any undefined behavior.\n- Maintain the correctness of the list structure during traversal and modification through loop invariants.\n- Guarantee that the output is a well-formed list, preserving the intended behavior of the `append` function."
    }
]