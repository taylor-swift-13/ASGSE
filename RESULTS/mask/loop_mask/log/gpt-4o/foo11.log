2025-09-01 19:15:27,636 - INFO  - 
FUNCTION INITIALIZATION
2025-09-01 19:15:27,636 - INFO  - ========================================

2025-09-01 19:15:27,773 - INFO  - 初始待处理函数: ['foo11', 'unknown']
2025-09-01 19:15:27,773 - INFO  - 现在处理函数 unknown

2025-09-01 19:15:27,773 - INFO  - 
GENERATE ANNOTATION FOR foo11
2025-09-01 19:15:27,773 - INFO  - ========================================

2025-09-01 19:15:27,773 - INFO  - 函数 foo11 已经初始化
2025-09-01 19:15:27,782 - INFO  - 
GENERATE LOOP INVARIANT FOR foo11
2025-09-01 19:15:27,782 - INFO  - ========================================

2025-09-01 19:15:27,791 - INFO  - file_name: foo11
2025-09-01 19:15:27,801 - DEBUG  - INNER_FLAG: False
2025-09-01 19:15:27,807 - INFO  - Variable Maps:[{'z3': 'z3@pre', 'z2': 'z2@pre', 'z1': 'z1@pre', 'y': 'y@pre', 'x': 'x@pre'}]
2025-09-01 19:15:27,807 - INFO  - Path conditions: ['x@pre >= 0 && x@pre <= 2 && y@pre <= 2 && y@pre >= 0']
2025-09-01 19:15:27,807 - INFO  - Pre condition: x@pre >= 0 && x@pre <= 2 && y@pre <= 2 && y@pre >= 0 && (z3 == z3@pre) * (z2 == z2@pre) * (z1 == z1@pre) * (y == y@pre) * (x == x@pre)
2025-09-01 19:15:27,808 - INFO  - Loop Condition: unknown()
2025-09-01 19:15:27,808 - INFO  - Array Names: []
2025-09-01 19:15:27,808 - INFO  - Updated Loop Conditions: ['unknown()']
2025-09-01 19:15:27,808 - INFO  - Global Unchanged Variables: ['z3', 'z2', 'z1']
2025-09-01 19:15:27,808 - INFO  - Non Inductive Variables: []
2025-09-01 19:15:27,808 - INFO  - Unchanged Arrays (Read-only): []
2025-09-01 19:15:49,568 - INFO  - think in natural language: ### Loop Verification Analysis ###

#### a. Loop Purpose and Structure ####

**Purpose:**  
The loop in the function `foo11` modifies the values of `x` and `y` repeatedly, incrementing both by 2 in each iteration. The loop continues to execute as long as the condition `unknown()` evaluates to true. The purpose of the loop cannot be fully determined because the governing condition (`unknown()`) is not explicitly defined. However, the loop appears to update `x` and `y` in a way that they grow linearly over time.

**Structure:**  
- **Governing Condition:** The loop executes as long as `unknown()` evaluates to true. The `unknown()` function is not defined in the given snippet, so its behavior is arbitrary.
- **Operations in the Body:**  
  Inside the loop body:
  ```c
  x = x + 2;
  y = y + 2;
  ```
  The variables `x` and `y` are incremented by 2 during each iteration.
- **Relevant Variables:**  
  - `x`: Initially constrained by the pre-condition `x >= 0 && x <= 2`. It is incremented by 2 in each iteration.
  - `y`: Initially constrained by the pre-condition `y >= 0 && y <= 2`. It is incremented by 2 in each iteration.
  - `z1`, `z2`, `z3`: These variables are passed as parameters but are unused in the loop or the function.

---

#### b. Sample and Analyze Variable Values ####

**Pre-Loop Sampling:**  
Before the loop begins, the values of the variables are constrained by the pre-condition:
- `x`: Between 0 and 2 (inclusive).
- `y`: Between 0 and 2 (inclusive).
- `z1`, `z2`, `z3`: Their values are unknown and unused in the loop.

**Post-Iteration Sampling:**  
The following table shows the values of `x` and `y` after each iteration, assuming the loop condition (`unknown()`) remains true:

| Iteration | `x` (initial: 0) | `y` (initial: 0) |
|-----------|------------------|------------------|
| 0         | 0                | 0                |
| 1         | 2                | 2                |
| 2         | 4                | 4                |
| 3         | 6                | 6                |
| 4         | 8                | 8                |
| 5         | 10               | 10               |

If the initial values of `x` and `y` differ (e.g., `x = 2`, `y = 2`), their increments will still follow the same pattern, increasing by 2 per iteration.

**Post-Loop Sampling:**  
The loop terminates when `unknown()` evaluates to false. At this point:
- `x` and `y` will have values that are multiples of 2, determined by the number of iterations executed before termination.
- Their exact values depend on the initial values and the number of iterations.

---

#### d. Loop Invariant Discussion ####

**Proposed Loop Invariant:**  
At the start of each iteration:
- `x` is equal to its initial value plus 2 times the number of completed iterations.
- `y` is equal to its initial value plus 2 times the number of completed iterations.

**Explanation of Validity:**  
The loop invariant holds because:
1. Both `x` and `y` are incremented by 2 during each iteration.
2. The pre-condition guarantees that `x` and `y` start within the range `[0, 2]`.
3. The invariant directly reflects the linear growth of `x` and `y` as a function of the number of iterations.

---

#### e. Establishment ####

**How the Invariant is Established:**  
Before the loop begins:
- The pre-condition guarantees that `x` and `y` are in the range `[0, 2]`.
- No iterations have occurred yet, so the invariant holds trivially: `x = initial_x` and `y = initial_y`.

---

#### f. Preservation ####

**How the Invariant is Preserved:**  
During each iteration:
1. Assume the invariant holds at the start of the iteration:  
   `x = initial_x + 2 * iterations_completed`  
   `y = initial_y + 2 * iterations_completed`
2. After the loop body executes:
   ```c
   x = x + 2;
   y = y + 2;
   ```
   The new values of `x` and `y` become:  
   `x = initial_x + 2 * (iterations_completed + 1)`  
   `y = initial_y + 2 * (iterations_completed + 1)`
3. Thus, the invariant is preserved.

---

#### g. Termination Analysis ####

**State at Termination:**  
The loop terminates when `unknown()` evaluates to false. At this point:
- `x` and `y` will have values that are multiples of 2, determined by the number of iterations executed.
- Their exact values depend on the initial values and the number of iterations.

**Invariant Validity at Termination:**  
The invariant remains valid at termination because:
- The loop condition does not affect the arithmetic progression of `x` and `y`.
- The invariant is independent of the termination condition.

---

#### h. Post-condition Correctness ####

The post-condition is not explicitly provided in the code snippet. However, we can infer the following:
- The loop invariant ensures that `x` and `y` are multiples of 2 at the end of the loop.
- If a specific post-condition is required, it must align with this property.

If the post-condition states that `x` and `y` are multiples of 2, it is correct. Otherwise, further clarification is needed to verify correctness.
2025-09-01 19:15:49,568 - INFO  - after const
2025-09-01 19:15:49,569 - INFO  - 
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
2025-09-01 19:15:49,569 - INFO  - after not in
2025-09-01 19:15:49,569 - INFO  - 
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
2025-09-01 19:15:49,569 - INFO  - after vars
2025-09-01 19:15:49,569 - INFO  - 
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant  PLACE_HOLDER_x ;
          loop invariant  PLACE_HOLDER_y ;
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
2025-09-01 19:15:49,569 - INFO  - after verification goal
2025-09-01 19:15:49,569 - INFO  - 
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant  PLACE_HOLDER_VERFICATION_GOAL ;
          loop invariant  PLACE_HOLDER_x ;
          loop invariant  PLACE_HOLDER_y ;
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
2025-09-01 19:15:49,573 - INFO  - 模板的内容为


/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
    */
    
void foo11(int x,int y,int z1,int z2,int z3) {

  
    
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          PLACE_HOLDER_FOR_LOOP
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
      /* mask_1 */
   
  }
2025-09-01 19:15:49,576 - INFO  - 模板的内容为


/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
    */
    
void foo11(int x,int y,int z1,int z2,int z3) {

  
    
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant  PLACE_HOLDER_x ;
          loop invariant  PLACE_HOLDER_y ;
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
      /* mask_1 */
   
  }
2025-09-01 19:15:49,580 - INFO  - 模板的内容为


/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
    */
    
void foo11(int x,int y,int z1,int z2,int z3) {

  
    
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant  PLACE_HOLDER_VERFICATION_GOAL ;
          loop invariant  PLACE_HOLDER_x ;
          loop invariant  PLACE_HOLDER_y ;
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
      /* mask_1 */
   
  }
2025-09-01 19:15:49,580 - DEBUG  - user_prompt_traival
2025-09-01 19:15:49,580 - DEBUG  - Role:
You are a helpful AI software assistant specializing in reasoning about code behavior. Your task is to analyze C programs and identify loop invariants that can be used to verify program properties using Frama-C.

Task:
Given a C program with a loop, generate the necessary loop invariants in ACSL (ANSI/ISO C Specification Language) annotations. These invariants will help Frama-C verify the post-condition of the program.



Inputs:
- The pre-condition before the loop begins execution.
- A full C loop program with invariant annotations containing `PLACE_HOLDER` that need to be filled.

Output:
Provide the complete C code with the loop invariant and other relevant ACSL annotations, where all placeholders are correctly filled in ```c ```.

Rules:
- Do not modify the the existing annotations template. You are only allowed to repalce the placeholders PLACE_HOLDER_TO_FILL before loop with appropriate logical expressions to make the invariants meaningful and valid.
- Only use keywords and constructs supported in ACSL annotations for loops.
- Do not add any natural language explanations after ACSL annotations.
- When `unkonwn()` used as the loop condition, the number of loop iterations can be any non-negative integer, and the invariant must hold for all cases.





Consider the following C loop:

Pre-condition: `\at(x,Pre) >= 0 && \at(x,Pre) <= 2 && \at(y,Pre) <= 2 && \at(y,Pre) >= 0 && (z3 == \at(z3,Pre)) * (z2 == \at(z2,Pre)) * (z1 == \at(z1,Pre)) * (y == \at(y,Pre)) * (x == \at(x,Pre))`

Loop program: `


/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
    */
    
void foo11(int x,int y,int z1,int z2,int z3) {

  
    
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          PLACE_HOLDER_FOR_LOOP
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
      /* mask_1 */
   
  }`



2025-09-01 19:15:49,580 - DEBUG  - user_prompt_template
2025-09-01 19:15:49,580 - DEBUG  - Role:
You are a helpful AI software assistant specializing in reasoning about code behavior. Your task is to analyze C programs and identify loop invariants that can be used to verify program properties using Frama-C.

Task:
Given a C program with a loop, generate the necessary loop invariants in ACSL (ANSI/ISO C Specification Language) annotations. These invariants will help Frama-C verify the post-condition of the program.



Inputs:
- The pre-condition before the loop begins execution.
- A full C loop program with invariant annotations containing `PLACE_HOLDER` that need to be filled.

Output:
Provide the complete C code with the loop invariant and other relevant ACSL annotations, where all placeholders are correctly filled in ```c ```.

Rules:
- Do not modify the the existing annotations template. You are only allowed to repalce the placeholders PLACE_HOLDER_TO_FILL before loop with appropriate logical expressions to make the invariants meaningful and valid.
- Only use keywords and constructs supported in ACSL annotations for loops.
- Do not add any natural language explanations after ACSL annotations.
- When `unkonwn()` used as the loop condition, the number of loop iterations can be any non-negative integer, and the invariant must hold for all cases.

- Generate loop invariants with equality constraints as comprehensively as possible.



Consider the following C loop:

Pre-condition: `\at(x,Pre) >= 0 && \at(x,Pre) <= 2 && \at(y,Pre) <= 2 && \at(y,Pre) >= 0 && (z3 == \at(z3,Pre)) * (z2 == \at(z2,Pre)) * (z1 == \at(z1,Pre)) * (y == \at(y,Pre)) * (x == \at(x,Pre))`

Loop program: `


/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
    */
    
void foo11(int x,int y,int z1,int z2,int z3) {

  
    
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant  PLACE_HOLDER_x ;
          loop invariant  PLACE_HOLDER_y ;
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
      /* mask_1 */
   
  }`



2025-09-01 19:15:49,580 - DEBUG  - user_prompt_verification
2025-09-01 19:15:49,580 - DEBUG  - Role:
You are a helpful AI software assistant specializing in reasoning about code behavior. Your task is to analyze C programs and identify loop invariants that can be used to verify program properties using Frama-C.

Task:
Given a C program with a loop, generate the necessary loop invariants in ACSL (ANSI/ISO C Specification Language) annotations. These invariants will help Frama-C verify the post-condition of the program.



Inputs:
- The pre-condition before the loop begins execution.
- A full C loop program with invariant annotations containing `PLACE_HOLDER` that need to be filled.

Output:
Provide the complete C code with the loop invariant and other relevant ACSL annotations, where all placeholders are correctly filled in ```c ```.

Rules:
- Do not modify the the existing annotations template. You are only allowed to repalce the placeholders PLACE_HOLDER_TO_FILL before loop with appropriate logical expressions to make the invariants meaningful and valid.
- Only use keywords and constructs supported in ACSL annotations for loops.
- Do not add any natural language explanations after ACSL annotations.
- When `unkonwn()` used as the loop condition, the number of loop iterations can be any non-negative integer, and the invariant must hold for all cases.

- Generate loop invariants with equality constraints as comprehensively as possible.
- Please first try to directly use the verification goal as the loop invariant at `PLACE_HOLDER_VERFICATION_GOAL`. Often, the verification goal (assertion) also holds throughout the loop; in that case, it can be used directly as the invariant.


Consider the following C loop:

Pre-condition: `\at(x,Pre) >= 0 && \at(x,Pre) <= 2 && \at(y,Pre) <= 2 && \at(y,Pre) >= 0 && (z3 == \at(z3,Pre)) * (z2 == \at(z2,Pre)) * (z1 == \at(z1,Pre)) * (y == \at(y,Pre)) * (x == \at(x,Pre))`

Loop program: `


/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
    */
    
void foo11(int x,int y,int z1,int z2,int z3) {

  
    
            
        /* >>> LOOP INVARIANT TO FILL <<< */
        
            /*@
          loop invariant  PLACE_HOLDER_VERFICATION_GOAL ;
          loop invariant  PLACE_HOLDER_x ;
          loop invariant  PLACE_HOLDER_y ;
          loop invariant z3 == \at(z3,Pre);
          loop invariant z2 == \at(z2,Pre);
          loop invariant z1 == \at(z1,Pre);
            */
            while (unknown()) {
      
      x  = x + 2;
      y  = y + 2;

    }
            
      /* mask_1 */
   
  }`



2025-09-01 19:15:53,466 - DEBUG  - invgen reasoning
2025-09-01 19:15:53,466 - DEBUG  - ```c
/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
*/
void foo11(int x, int y, int z1, int z2, int z3) {

    /*@
        loop invariant x >= \at(x, Pre) && y >= \at(y, Pre);
        loop invariant x % 2 == \at(x, Pre) % 2 && y % 2 == \at(y, Pre) % 2;
        loop invariant x == \at(x, Pre) + 2 * (\at(x, Here) - \at(x, Pre)) / 2;
        loop invariant y == \at(y, Pre) + 2 * (\at(y, Here) - \at(y, Pre)) / 2;
        loop invariant z1 == \at(z1, Pre) && z2 == \at(z2, Pre) && z3 == \at(z3, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }

    /* mask_1 */
}
```
2025-09-01 19:15:57,442 - DEBUG  - invgen reasoning
2025-09-01 19:15:57,442 - DEBUG  - ```c
/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
*/
void foo11(int x, int y, int z1, int z2, int z3) {

    /*@
        loop invariant x == \at(x, Pre) + 2 * (\at(x, Here) - \at(x, Pre)) / 2;
        loop invariant y == \at(y, Pre) + 2 * (\at(y, Here) - \at(y, Pre)) / 2;
        loop invariant z3 == \at(z3, Pre);
        loop invariant z2 == \at(z2, Pre);
        loop invariant z1 == \at(z1, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }

    /* mask_1 */
}
```
2025-09-01 19:16:01,256 - DEBUG  - invgen reasoning
2025-09-01 19:16:01,256 - DEBUG  - ```c
/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
*/
void foo11(int x, int y, int z1, int z2, int z3) {

    /*@
        loop invariant x >= 0 && y >= 0;
        loop invariant x % 2 == \at(x, Pre) % 2;
        loop invariant y % 2 == \at(y, Pre) % 2;
        loop invariant x - y == \at(x, Pre) - \at(y, Pre);
        loop invariant z3 == \at(z3, Pre);
        loop invariant z2 == \at(z2, Pre);
        loop invariant z1 == \at(z1, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }

    /* mask_1 */
}
```
2025-09-01 19:16:01,256 - INFO  - 生成循环不变量
2025-09-01 19:16:01,256 - INFO  - 
/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
*/
void foo11(int x, int y, int z1, int z2, int z3) {

    /*@
        loop invariant x == \at(x, Pre) + 2 * (\at(x, Here) - \at(x, Pre)) / 2;
        loop invariant y == \at(y, Pre) + 2 * (\at(y, Here) - \at(y, Pre)) / 2;
        loop invariant z3 == \at(z3, Pre);
        loop invariant z2 == \at(z2, Pre);
        loop invariant z1 == \at(z1, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }

    /* mask_1 */
}

2025-09-01 19:16:12,250 - INFO  - syntax Correct
2025-09-01 19:16:15,932 - INFO  - Validate:
2025-09-01 19:16:15,932 - INFO  - [True, True, True, True, True]
2025-09-01 19:16:15,932 - INFO  - 
2025-09-01 19:16:15,932 - INFO  - Verify:
2025-09-01 19:16:15,932 - INFO  - []
2025-09-01 19:16:15,932 - INFO  - 
2025-09-01 19:16:15,932 - INFO  - 注释过不变量的代码
2025-09-01 19:16:15,932 - INFO  - 
/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
*/
void foo11(int x, int y, int z1, int z2, int z3) {

    /*@
        loop invariant x == \at(x, Pre) + 2 * (\at(x, Here) - \at(x, Pre)) / 2;
        loop invariant y == \at(y, Pre) + 2 * (\at(y, Here) - \at(y, Pre)) / 2;
        loop invariant z3 == \at(z3, Pre);
        loop invariant z2 == \at(z2, Pre);
        loop invariant z1 == \at(z1, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }

    /* mask_1 */
}

2025-09-01 19:16:30,602 - INFO  - ACSL 格式的循环不变量
2025-09-01 19:16:30,603 - INFO  - /*@
        loop invariant x == \at(x, Pre) + 2 * (\at(x, Here) - \at(x, Pre)) / 2;
        loop invariant y == \at(y, Pre) + 2 * (\at(y, Here) - \at(y, Pre)) / 2;
        loop invariant z3 == \at(z3, Pre);
        loop invariant z2 == \at(z2, Pre);
        loop invariant z1 == \at(z1, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }
2025-09-01 19:16:30,603 - INFO  - VST 格式的循环不变量
2025-09-01 19:16:30,603 - INFO  - /*@ Inv
    (x == x@pre + 2 * (\at(x, Here) - x@pre) / 2) &&
(y == y@pre + 2 * (\at(y, Here) - y@pre) / 2) &&
(z3 == z3@pre) &&
(z2 == z2@pre) &&
(z1 == z1@pre
        loop assigns x, y
        loop variant 0 // unknown() does not guarantee termination, so no decreasing variant can be defined)
    */
    
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }
2025-09-01 19:16:30,603 - INFO  - PARTIAL CORRECT INVARIANT
2025-09-01 19:16:30,603 - INFO  - 继续符号执行
2025-09-01 19:16:30,603 - INFO  - 
/*@
    requires x >= 0 && x <= 2 && y <= 2 && y >= 0;
*/
void foo11(int x, int y, int z1, int z2, int z3) {

    /*@
        loop invariant x == \at(x, Pre) + 2 * (\at(x, Here) - \at(x, Pre)) / 2;
        loop invariant y == \at(y, Pre) + 2 * (\at(y, Here) - \at(y, Pre)) / 2;
        loop invariant z3 == \at(z3, Pre);
        loop invariant z2 == \at(z2, Pre);
        loop invariant z1 == \at(z1, Pre);
        loop assigns x, y;
        loop variant 0; // unknown() does not guarantee termination, so no decreasing variant can be defined
    */
    while (unknown()) {
        x = x + 2;
        y = y + 2;
    }

    /* mask_1 */
}

2025-09-01 19:16:41,603 - INFO  - syntax Correct
2025-09-01 19:16:45,335 - INFO  - Validate:
2025-09-01 19:16:45,335 - INFO  - [True, True, True, True, True]
2025-09-01 19:16:45,335 - INFO  - 
2025-09-01 19:16:45,335 - INFO  - Verify:
2025-09-01 19:16:45,335 - INFO  - []
2025-09-01 19:16:45,335 - INFO  - 
2025-09-01 19:16:45,336 - INFO  - CORRECT INVARIANT
2025-09-01 19:17:00,064 - INFO  - ========================================
2025-09-01 19:17:00,065 - INFO  - first_pass:
2025-09-01 19:17:00,065 - INFO  - syntax=1, valid=1,satisfy=1
2025-09-01 19:17:00,065 - INFO  - ========================================
