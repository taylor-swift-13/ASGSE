[kernel] Parsing out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c (with preprocessing)
[kernel:typing:no-proto] out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c:43: Warning: 
  Calling function unknown1 that is declared without prototype.
  Its formals will be inferred from actual arguments
[wp] Running WP plugin...
[kernel:annot:missing-spec] out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c:6: Warning: 
  Neither code nor specification for function unknown1, generating default assigns from the prototype
[wp] Warning: Missing RTE guards
[wp] 42 goals scheduled
[wp] [Timeout] typed_foo_loop_invariant_preserved (Qed 7ms) (Z3)
[wp] [Timeout] typed_foo_loop_invariant_3_established (Qed 3ms) (Z3)
[wp] [Timeout] typed_foo_loop_invariant_4_preserved (Qed 20ms) (Z3)
[wp] [Timeout] typed_foo_loop_invariant_5_established (Qed 3ms) (Z3)
[wp] [Timeout] typed_foo_loop_invariant_8_preserved (Qed 23ms) (Z3)
[wp] Proved goals:   37 / 42
  Qed:              27
  Alt-Ergo 2.6.2:    7 (8ms-28ms-76ms)
  Z3 4.8.6:          3 (20ms)
  Timeout:           5
------------------------------------------------------------
  Function foo
------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 18):
Let x = i % 2.
Let x_1 = j % 2.
Let x_2 = -i.
Let x_3 = j - i.
Let x_4 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_4).
  (* Goal *)
  When: (to_uint32(2 + i) % 2) = 1.
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x = 1) -> (x_1 = 1)).
  (* Invariant *)
  Have: ((x = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x = 0) -> (x_1 = 0)).
  (* Invariant *)
  Have: (x_3 * x_4) = b.
  (* Invariant *)
  Have: (b / x_4) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_3) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x = 1)) \/ ((x = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x = 0) /\ (x_1 = 0)) \/ ((x = 1) /\ (x_1 = 1)).
  (* Invariant *)
  Have: ((x = 0) /\ (x_1 = 0)) \/ ((x != 0) /\ (x_1 != 0)).
  (* Invariant *)
  Have: ((x != 0) -> (x_1 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
}
Prove: (to_uint32(1 + j) % 2) = 1.
Prover Z3 4.8.6 returns Timeout (Qed:7ms) (8s)
Prover Alt-Ergo 2.6.2 returns Timeout (Qed:7ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 18):
Prove: true.
Prover Qed returns Valid (0.54ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 19):
Let x = i % 2.
Let x_1 = j % 2.
Let x_2 = -i.
Let x_3 = j - i.
Let x_4 = b + j - i.
Let x_5 = to_uint32(2 + i).
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_4).
  (* Goal *)
  When: (x_5 % 2) = 0.
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x = 1) -> (x_1 = 1)).
  (* Invariant *)
  Have: ((x = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x = 0) -> (x_1 = 0)).
  (* Invariant *)
  Have: (x_3 * x_4) = b.
  (* Invariant *)
  Have: (b / x_4) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_3) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x = 1)) \/ ((x = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x = 0) /\ (x_1 = 0)) \/ ((x = 1) /\ (x_1 = 1)).
  (* Invariant *)
  Have: ((x = 0) /\ (x_1 = 0)) \/ ((x != 0) /\ (x_1 != 0)).
  (* Invariant *)
  Have: ((x != 0) -> (x_1 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
}
Prove: x_5 <= to_uint32(2 + j).
Prover Z3 4.8.6 returns Valid (Qed:6ms) (20ms) (46500)
Prover Alt-Ergo 2.6.2 returns Valid (Qed:6ms) (9ms) (437)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 19):
Prove: true.
Prover Qed returns Valid (2ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 20):
Let x = to_uint32(2 + i).
Let x_1 = to_uint32(2 + j).
Let x_2 = i % 2.
Let x_3 = j % 2.
Let x_4 = -i.
Let x_5 = j - i.
Let x_6 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_6).
  (* Goal *)
  When: (x % 2) = 0.
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_2 = 1) -> (x_3 = 1)).
  (* Invariant *)
  Have: ((x_2 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_2 = 0) -> (x_3 = 0)).
  (* Invariant *)
  Have: (x_5 * x_6) = b.
  (* Invariant *)
  Have: (b / x_6) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_5) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_2 = 1)) \/ ((x_2 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_2 = 0) /\ (x_3 = 0)) \/ ((x_2 = 1) /\ (x_3 = 1)).
  (* Invariant *)
  Have: ((x_2 = 0) /\ (x_3 = 0)) \/ ((x_2 != 0) /\ (x_3 != 0)).
  (* Invariant *)
  Have: ((x_2 != 0) -> (x_3 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: x <= x_1.
}
Prove: (x_1 % 2) = 0.
Prover Z3 4.8.6 returns Valid (Qed:6ms) (10ms) (47142)
Prover Alt-Ergo 2.6.2 returns Valid (Qed:6ms) (8ms) (255)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 20):
Assume { Type: is_sint32(flag_0). (* Residual *) When: flag_0 != 0. }
Prove: false.
Prover Z3 4.8.6 returns Timeout (Qed:3ms) (8s)
Prover Alt-Ergo 2.6.2 returns Timeout (Qed:3ms) (8s)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 21):
Let x = to_uint32(2 + i).
Let x_1 = x % 2.
Let x_2 = j_1 % 2.
Let x_3 = i % 2.
Let x_4 = j % 2.
Let x_5 = -i.
Let x_6 = j - i.
Let x_7 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j_1) /\ is_uint32(j) /\
      is_sint32(tmp_0) /\ is_uint32(x_7).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_3 = 1) -> (x_4 = 1)).
  (* Invariant *)
  Have: ((x_3 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_3 = 0) -> (x_4 = 0)).
  (* Invariant *)
  Have: (x_6 * x_7) = b.
  (* Invariant *)
  Have: (b / x_7) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_6) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_3 = 1)) \/ ((x_3 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_3 = 0) /\ (x_4 = 0)) \/ ((x_3 = 1) /\ (x_4 = 1)).
  (* Invariant *)
  Have: ((x_3 = 0) /\ (x_4 = 0)) \/ ((x_3 != 0) /\ (x_4 != 0)).
  (* Invariant *)
  Have: ((x_3 != 0) -> (x_4 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  If to_uint32(x_1) = 0
  Then { Have: to_uint32(2 + j) = j_1. }
  Else { Have: to_uint32(1 + j) = j_1. }
  (* Invariant *)
  Have: ((x_1 = 1) -> (x_2 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x <= j_1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_2 = 0)).
}
Prove: (to_uint32(1 + b + j - i) * (j_1 - x)) = to_uint32(b + to_uint32(x_6)).
Prover Z3 4.8.6 returns Timeout (Qed:20ms) (8s)
Prover Alt-Ergo 2.6.2 returns Timeout (Qed:20ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 21):
Prove: true.
Prover Qed returns Valid (0.93ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 22):
Let x = to_uint32(2 + i).
Let x_1 = x % 2.
Let x_2 = j_1 % 2.
Let x_3 = -i.
Let x_4 = to_uint32(1 + b + j - i).
Let x_5 = x_4 * (j_1 - x).
Let x_6 = j - i.
Let x_7 = i % 2.
Let x_8 = j % 2.
Let x_9 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j_1) /\ is_uint32(j) /\
      is_sint32(tmp_0) /\ is_uint32(x_9) /\ is_uint32(x_5).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_7 = 1) -> (x_8 = 1)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (x_8 = 0)).
  (* Invariant *)
  Have: (x_6 * x_9) = b.
  (* Invariant *)
  Have: (b / x_9) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_6) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_7 = 1)) \/ ((x_7 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_7 = 0) /\ (x_8 = 0)) \/ ((x_7 = 1) /\ (x_8 = 1)).
  (* Invariant *)
  Have: ((x_7 = 0) /\ (x_8 = 0)) \/ ((x_7 != 0) /\ (x_8 != 0)).
  (* Invariant *)
  Have: ((x_7 != 0) -> (x_8 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  Have: x_5 = to_uint32(b + to_uint32(x_6)).
  If to_uint32(x_1) = 0
  Then { Have: to_uint32(2 + j) = j_1. }
  Else { Have: to_uint32(1 + j) = j_1. }
  (* Invariant *)
  Have: ((x_1 = 1) -> (x_2 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x <= j_1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_2 = 0)).
}
Prove: (x_5 / x_4) = x_5.
Prover Z3 4.8.6 returns Valid (Qed:22ms) (20ms) (56205)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 22):
Prove: (0 / 0) = 0.
Prover Z3 4.8.6 returns Timeout (Qed:3ms) (8s)
Prover Alt-Ergo 2.6.2 returns Timeout (Qed:3ms) (8s)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 23):
Let x = to_uint32(2 + i).
Let x_1 = x % 2.
Let x_2 = j_1 % 2.
Let x_3 = -i.
Let x_4 = to_uint32(1 + b + j - i).
Let x_5 = x_4 * (j_1 - x).
Let x_6 = j - i.
Let x_7 = i % 2.
Let x_8 = j % 2.
Let x_9 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j_1) /\ is_uint32(j) /\
      is_sint32(tmp_0) /\ is_uint32(x_9) /\ is_uint32(x_5).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_7 = 1) -> (x_8 = 1)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (x_8 = 0)).
  (* Invariant *)
  Have: (x_6 * x_9) = b.
  (* Invariant *)
  Have: (b / x_9) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_6) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_7 = 1)) \/ ((x_7 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_7 = 0) /\ (x_8 = 0)) \/ ((x_7 = 1) /\ (x_8 = 1)).
  (* Invariant *)
  Have: ((x_7 = 0) /\ (x_8 = 0)) \/ ((x_7 != 0) /\ (x_8 != 0)).
  (* Invariant *)
  Have: ((x_7 != 0) -> (x_8 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  Have: (x_5 = to_uint32(b + to_uint32(x_6))) /\ ((x_5 / x_4) = x_5).
  If to_uint32(x_1) = 0
  Then { Have: to_uint32(2 + j) = j_1. }
  Else { Have: to_uint32(1 + j) = j_1. }
  (* Invariant *)
  Have: ((x_1 = 1) -> (x_2 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x <= j_1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_2 = 0)).
}
Prove: (x_5 / 2) = x_5.
Prover Alt-Ergo 2.6.2 returns Valid (Qed:23ms) (76ms) (9980)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 23):
Prove: true.
Prover Qed returns Valid (2ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 24):
Let x = -i.
Let x_1 = to_uint32(1 + b + j - i).
Let x_2 = to_uint32(2 + i).
Let x_3 = j_1 - x_2.
Let x_4 = x_1 * x_3.
Let x_5 = x_2 % 2.
Let x_6 = j_1 % 2.
Let x_7 = j - i.
Let x_8 = i % 2.
Let x_9 = j % 2.
Let x_10 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j_1) /\ is_uint32(j) /\
      is_sint32(tmp_0) /\ is_uint32(x_10) /\ is_uint32(x_4).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_8 = 1) -> (x_9 = 1)).
  (* Invariant *)
  Have: ((x_8 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_8 = 0) -> (x_9 = 0)).
  (* Invariant *)
  Have: (x_7 * x_10) = b.
  (* Invariant *)
  Have: (b / x_10) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_7) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_8 = 1)) \/ ((x_8 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_8 = 0) /\ (x_9 = 0)) \/ ((x_8 = 1) /\ (x_9 = 1)).
  (* Invariant *)
  Have: ((x_8 = 0) /\ (x_9 = 0)) \/ ((x_8 != 0) /\ (x_9 != 0)).
  (* Invariant *)
  Have: ((x_8 != 0) -> (x_9 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  Have: (x_4 = to_uint32(b + to_uint32(x_7))) /\ ((x_4 / 2) = x_4).
  If to_uint32(x_5) = 0
  Then { Have: to_uint32(2 + j) = j_1. }
  Else { Have: to_uint32(1 + j) = j_1. }
  (* Invariant *)
  Have: ((x_5 = 1) -> (x_6 = 1)).
  (* Invariant *)
  Have: ((x_5 = 0) -> (x_2 <= j_1)).
  (* Invariant *)
  Have: ((x_5 = 0) -> (x_6 = 0)).
  (* Invariant *)
  Have: (x_4 / x_1) = x_4.
}
Prove: (x_4 / x_3) = x_4.
Prover Z3 4.8.6 returns Valid (Qed:24ms) (70ms) (286354)
Prover Alt-Ergo 2.6.2 returns Valid (Qed:24ms) (64ms) (10185)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 24):
Prove: true.
Prover Qed returns Valid (2ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 25):
Let x = -i.
Let x_1 = to_uint32(1 + b + j_1 - i).
Let x_2 = to_uint32(2 + i).
Let x_3 = j - x_2.
Let x_4 = x_1 * x_3.
Let x_5 = x_2 % 2.
Let x_6 = j % 2.
Let x_7 = j_1 - i.
Let x_8 = i % 2.
Let x_9 = j_1 % 2.
Let x_10 = b + j_1 - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_uint32(j_1) /\
      is_sint32(tmp_0) /\ is_uint32(x_10) /\ is_uint32(x_4).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_8 = 1) -> (x_9 = 1)).
  (* Invariant *)
  Have: ((x_8 = 0) -> (i <= j_1)).
  (* Invariant *)
  Have: ((x_8 = 0) -> (x_9 = 0)).
  (* Invariant *)
  Have: (x_7 * x_10) = b.
  (* Invariant *)
  Have: (b / x_10) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_7) = b.
  (* Invariant *)
  Have: 0 < j_1.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j_1).
  (* Invariant *)
  Have: ((j_1 = i) /\ (x_8 = 1)) \/ ((x_8 = 0) /\ ((1 + i) = j_1)).
  (* Invariant *)
  Have: ((x_8 = 0) /\ (x_9 = 0)) \/ ((x_8 = 1) /\ (x_9 = 1)).
  (* Invariant *)
  Have: ((x_8 = 0) /\ (x_9 = 0)) \/ ((x_8 != 0) /\ (x_9 != 0)).
  (* Invariant *)
  Have: ((x_8 != 0) -> (x_9 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  Have: (x_4 = to_uint32(b + to_uint32(x_7))) /\ ((x_4 / x_3) = x_4).
  If to_uint32(x_5) = 0
  Then { Have: to_uint32(2 + j_1) = j. }
  Else { Have: to_uint32(1 + j_1) = j. }
  (* Invariant *)
  Have: ((x_5 = 1) -> (x_6 = 1)).
  (* Invariant *)
  Have: ((x_5 = 0) -> (x_2 <= j)).
  (* Invariant *)
  Have: ((x_5 = 0) -> (x_6 = 0)).
  (* Invariant *)
  Have: (x_4 / x_1) = x_4.
  (* Invariant *)
  Have: (x_4 / 2) = x_4.
}
Prove: (j + x_4) = (x_2 + x_1).
Prover Z3 4.8.6 returns Timeout (Qed:23ms) (8s)
Prover Alt-Ergo 2.6.2 returns Timeout (Qed:23ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 25):
Prove: true.
Prover Qed returns Valid (3ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 26):
Let x = -i.
Let x_1 = j - i.
Let x_2 = to_uint32(b + to_uint32(x_1)).
Let x_3 = to_uint32(1 + b + j - i).
Let x_4 = -x_2.
Let x_5 = x_3 - x_2.
Let x_6 = to_uint32(2 + i).
Let x_7 = x_6 % 2.
Let x_8 = x_6 + x_3 - x_2.
Let x_9 = x_8 % 2.
Let x_10 = i % 2.
Let x_11 = j % 2.
Let x_12 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_12) /\ is_uint32(x_8).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_10 = 1) -> (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (x_11 = 0)).
  (* Invariant *)
  Have: (x_1 * x_12) = b.
  (* Invariant *)
  Have: (b / x_12) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_1) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_10 = 1)) \/ ((x_10 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 = 1) /\ (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 != 0) /\ (x_11 != 0)).
  (* Invariant *)
  Have: ((x_10 != 0) -> (x_11 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  If to_uint32(x_7) = 0
  Then { Have: (to_uint32(2 + j) + x_2) = (x_6 + x_3). }
  Else { Have: (to_uint32(1 + j) + x_2) = (x_6 + x_3). }
  (* Invariant *)
  Have: ((x_7 = 1) -> (x_9 = 1)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (x_2 <= x_3)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (x_9 = 0)).
  (* Invariant *)
  Have: (x_3 * x_5) = x_2.
  (* Invariant *)
  Have: (x_2 / x_3) = x_2.
  (* Invariant *)
  Have: (x_2 / 2) = x_2.
  (* Invariant *)
  Have: (x_2 / x_5) = x_2.
}
Prove: x_2 < (x_6 + x_3).
Prover Z3 4.8.6 returns Valid (Qed:20ms) (20ms) (62534)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 26):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 27):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 27):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 28):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 28):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 29):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 29):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 30):
Prove: true.
Prover Qed returns Valid (3ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 30):
Prove: true.
Prover Qed returns Valid (0.85ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 31):
Prove: true.
Prover Qed returns Valid (3ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 31):
Prove: true.
Prover Qed returns Valid (0.97ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 32):
Prove: true.
Prover Qed returns Valid (3ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 32):
Prove: true.
Prover Qed returns Valid

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 33):
Let x = -i.
Let x_1 = j - i.
Let x_2 = to_uint32(b + to_uint32(x_1)).
Let x_3 = to_uint32(2 + i).
Let x_4 = to_uint32(1 + b + j - i).
Let x_5 = -x_2.
Let x_6 = x_4 - x_2.
Let x_7 = x_3 % 2.
Let x_8 = x_3 + x_4 - x_2.
Let x_9 = x_8 % 2.
Let x_10 = i % 2.
Let x_11 = j % 2.
Let x_12 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_12) /\ is_uint32(x_8).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_10 = 1) -> (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (x_11 = 0)).
  (* Invariant *)
  Have: (x_1 * x_12) = b.
  (* Invariant *)
  Have: (b / x_12) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_1) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_10 = 1)) \/ ((x_10 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 = 1) /\ (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 != 0) /\ (x_11 != 0)).
  (* Invariant *)
  Have: ((x_10 != 0) -> (x_11 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  If to_uint32(x_7) = 0
  Then { Have: (to_uint32(2 + j) + x_2) = (x_3 + x_4). }
  Else { Have: (to_uint32(1 + j) + x_2) = (x_3 + x_4). }
  (* Invariant *)
  Have: ((x_7 = 1) -> (x_9 = 1)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (x_2 <= x_4)).
  (* Invariant *)
  Have: ((x_7 = 0) -> (x_9 = 0)).
  (* Invariant *)
  Have: (x_4 * x_6) = x_2.
  (* Invariant *)
  Have: (x_2 / x_4) = x_2.
  (* Invariant *)
  Have: (x_2 / 2) = x_2.
  (* Invariant *)
  Have: (x_2 / x_6) = x_2.
  (* Invariant *)
  Have: x_2 < (x_3 + x_4).
}
Prove: ((x_7 = 1) /\ (x_2 = x_4)) \/ ((x_7 = 0) /\ ((1 + x_2) = x_4)).
Prover Z3 4.8.6 returns Valid (Qed:22ms) (20ms) (85589)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 33):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 34):
Let x = to_uint32(2 + i).
Let x_1 = x % 2.
Let x_2 = -i.
Let x_3 = j - i.
Let x_4 = to_uint32(b + to_uint32(x_3)).
Let x_5 = to_uint32(1 + b + j - i).
Let x_6 = -x_4.
Let x_7 = x_5 - x_4.
Let x_8 = x + x_5 - x_4.
Let x_9 = x_8 % 2.
Let x_10 = i % 2.
Let x_11 = j % 2.
Let x_12 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_12) /\ is_uint32(x_8).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_10 = 1) -> (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (x_11 = 0)).
  (* Invariant *)
  Have: (x_3 * x_12) = b.
  (* Invariant *)
  Have: (b / x_12) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_3) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_10 = 1)) \/ ((x_10 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 = 1) /\ (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 != 0) /\ (x_11 != 0)).
  (* Invariant *)
  Have: ((x_10 != 0) -> (x_11 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  If to_uint32(x_1) = 0
  Then { Have: (to_uint32(2 + j) + x_4) = (x + x_5). }
  Else { Have: (to_uint32(1 + j) + x_4) = (x + x_5). }
  (* Invariant *)
  Have: ((x_1 = 1) -> (x_9 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_4 <= x_5)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_9 = 0)).
  (* Invariant *)
  Have: (x_5 * x_7) = x_4.
  (* Invariant *)
  Have: (x_4 / x_5) = x_4.
  (* Invariant *)
  Have: (x_4 / 2) = x_4.
  (* Invariant *)
  Have: (x_4 / x_7) = x_4.
  (* Invariant *)
  Have: x_4 < (x + x_5).
  (* Invariant *)
  Have: ((x_1 = 1) /\ (x_4 = x_5)) \/ ((x_1 = 0) /\ ((1 + x_4) = x_5)).
}
Prove: ((x_1 = 0) /\ (x_9 = 0)) \/ ((x_1 = 1) /\ (x_9 = 1)).
Prover Z3 4.8.6 returns Valid (Qed:26ms) (10ms) (50777)
Prover Alt-Ergo 2.6.2 returns Valid (Qed:26ms) (12ms) (810)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 34):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 35):
Let x = to_uint32(2 + i).
Let x_1 = x % 2.
Let x_2 = -i.
Let x_3 = to_uint32(1 + b + j - i).
Let x_4 = j - i.
Let x_5 = to_uint32(b + to_uint32(x_4)).
Let x_6 = -x_5.
Let x_7 = x + x_3 - x_5.
Let x_8 = x_7 % 2.
Let x_9 = x_3 - x_5.
Let x_10 = i % 2.
Let x_11 = j % 2.
Let x_12 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_12) /\ is_uint32(x_7).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_10 = 1) -> (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (x_11 = 0)).
  (* Invariant *)
  Have: (x_4 * x_12) = b.
  (* Invariant *)
  Have: (b / x_12) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_4) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_10 = 1)) \/ ((x_10 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 = 1) /\ (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 != 0) /\ (x_11 != 0)).
  (* Invariant *)
  Have: ((x_10 != 0) -> (x_11 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  If to_uint32(x_1) = 0
  Then { Have: (to_uint32(2 + j) + x_5) = (x + x_3). }
  Else { Have: (to_uint32(1 + j) + x_5) = (x + x_3). }
  (* Invariant *)
  Have: ((x_1 = 1) -> (x_8 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_5 <= x_3)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_8 = 0)).
  (* Invariant *)
  Have: (x_3 * x_9) = x_5.
  (* Invariant *)
  Have: (x_5 / x_3) = x_5.
  (* Invariant *)
  Have: (x_5 / 2) = x_5.
  (* Invariant *)
  Have: (x_5 / x_9) = x_5.
  (* Invariant *)
  Have: x_5 < (x + x_3).
  (* Invariant *)
  Have: ((x_1 = 1) /\ (x_5 = x_3)) \/ ((x_1 = 0) /\ ((1 + x_5) = x_3)).
  (* Invariant *)
  Have: ((x_1 = 0) /\ (x_8 = 0)) \/ ((x_1 = 1) /\ (x_8 = 1)).
}
Prove: ((x_1 = 0) /\ (x_8 = 0)) \/ ((x_1 != 0) /\ (x_8 != 0)).
Prover Z3 4.8.6 returns Valid (Qed:27ms) (10ms) (52737)
Prover Alt-Ergo 2.6.2 returns Valid (Qed:27ms) (9ms) (1013)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 35):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 36):
Prove: true.
Prover Qed returns Valid (3ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 36):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 37):
Let x = to_uint32(2 + i).
Let x_1 = x % 2.
Let x_2 = -i.
Let x_3 = to_uint32(1 + b + j - i).
Let x_4 = j - i.
Let x_5 = to_uint32(b + to_uint32(x_4)).
Let x_6 = -x_5.
Let x_7 = x + x_3 - x_5.
Let x_8 = x_7 % 2.
Let x_9 = x_3 - x_5.
Let x_10 = i % 2.
Let x_11 = j % 2.
Let x_12 = b + j - i.
Assume {
  Type: is_uint32(b) /\ is_uint32(i) /\ is_uint32(j) /\ is_sint32(tmp_0) /\
      is_uint32(x_12) /\ is_uint32(x_7).
  (* Invariant *)
  Have: (0 / 0) = 0.
  (* Invariant *)
  Have: ((x_10 = 1) -> (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (i <= j)).
  (* Invariant *)
  Have: ((x_10 = 0) -> (x_11 = 0)).
  (* Invariant *)
  Have: (x_4 * x_12) = b.
  (* Invariant *)
  Have: (b / x_12) = b.
  (* Invariant *)
  Have: (b / 2) = b.
  (* Invariant *)
  Have: (b / x_4) = b.
  (* Invariant *)
  Have: 0 < j.
  (* Invariant *)
  Have: 0 <= i.
  (* Invariant *)
  Have: 0 <= b.
  (* Invariant *)
  Have: i <= (b + j).
  (* Invariant *)
  Have: ((j = i) /\ (x_10 = 1)) \/ ((x_10 = 0) /\ ((1 + i) = j)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 = 1) /\ (x_11 = 1)).
  (* Invariant *)
  Have: ((x_10 = 0) /\ (x_11 = 0)) \/ ((x_10 != 0) /\ (x_11 != 0)).
  (* Invariant *)
  Have: ((x_10 != 0) -> (x_11 != 0)).
  (* Invariant *)
  Have: 0 < i.
  (* Then *)
  Have: tmp_0 != 0.
  If to_uint32(x_1) = 0
  Then { Have: (to_uint32(2 + j) + x_5) = (x + x_3). }
  Else { Have: (to_uint32(1 + j) + x_5) = (x + x_3). }
  (* Invariant *)
  Have: ((x_1 = 1) -> (x_8 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_5 <= x_3)).
  (* Invariant *)
  Have: ((x_1 = 0) -> (x_8 = 0)).
  (* Invariant *)
  Have: (x_3 * x_9) = x_5.
  (* Invariant *)
  Have: (x_5 / x_3) = x_5.
  (* Invariant *)
  Have: (x_5 / 2) = x_5.
  (* Invariant *)
  Have: (x_5 / x_9) = x_5.
  (* Invariant *)
  Have: x_5 < (x + x_3).
  (* Invariant *)
  Have: ((x_1 = 1) /\ (x_5 = x_3)) \/ ((x_1 = 0) /\ ((1 + x_5) = x_3)).
  (* Invariant *)
  Have: ((x_1 = 0) /\ (x_8 = 0)) \/ ((x_1 = 1) /\ (x_8 = 1)).
  (* Invariant *)
  Have: ((x_1 = 0) /\ (x_8 = 0)) \/ ((x_1 != 0) /\ (x_8 != 0)).
  (* Invariant *)
  Have: ((x_1 != 0) -> (x_8 != 0)).
}
Prove: 0 < x.
Prover Z3 4.8.6 returns Valid (Qed:27ms) (10ms) (46843)
Prover Alt-Ergo 2.6.2 returns Valid (Qed:27ms) (15ms) (900)

------------------------------------------------------------

Goal Establishment of Invariant (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 37):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Loop assigns (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 38) (1/2):
Prove: true.
Prover Qed returns Valid

------------------------------------------------------------

Goal Loop assigns (file out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c, line 38) (2/2):
Call Result at line 43
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------
[wp:pedantic-assigns] out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c:4: Warning: 
  No 'assigns' specification for function 'unknown1'.
  Callers assumptions might be imprecise.
[wp:pedantic-assigns] out/ddlm2013_true-unreach-call_0005/ddlm2013_true-unreach-call_merged.c:6: Warning: 
  No 'assigns' specification for function 'foo'.
  Callers assumptions might be imprecise.
