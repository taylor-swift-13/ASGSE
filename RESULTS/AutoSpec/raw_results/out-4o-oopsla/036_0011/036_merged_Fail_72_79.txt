[kernel] Parsing out/036_0011/036_merged.c (with preprocessing)
[kernel:typing:no-proto] out/036_0011/036_merged.c:86: Warning: 
  Calling function unknown2 that is declared without prototype.
  Its formals will be inferred from actual arguments
[kernel:typing:no-proto] out/036_0011/036_merged.c:41: Warning: 
  Calling function unknown1 that is declared without prototype.
  Its formals will be inferred from actual arguments
[kernel:typing:no-proto] out/036_0011/036_merged.c:103: Warning: 
  Calling function unknown3 that is declared without prototype.
  Its formals will be inferred from actual arguments
[wp] Running WP plugin...
[kernel:annot:missing-spec] out/036_0011/036_merged.c:5: Warning: 
  Neither code nor specification for function unknown1, generating default assigns from the prototype
[kernel:annot:missing-spec] out/036_0011/036_merged.c:5: Warning: 
  Neither code nor specification for function unknown2, generating default assigns from the prototype
[kernel:annot:missing-spec] out/036_0011/036_merged.c:5: Warning: 
  Neither code nor specification for function unknown3, generating default assigns from the prototype
[wp] Warning: Missing RTE guards
[wp] out/036_0011/036_merged.c:103: Warning: 
  Missing assigns clause (assigns 'everything' instead)
[wp] 79 goals scheduled
[wp] [Timeout] typed_foo036_loop_invariant_preserved (Qed 54ms) (Z3)
[wp] [Timeout] typed_foo036_loop_invariant_8_preserved (Qed 71ms) (Z3)
[wp] [Timeout] typed_foo036_loop_invariant_9_preserved (Qed 75ms) (Z3)
[wp] [Timeout] typed_foo036_loop_invariant_30_preserved (Qed 63ms) (Z3)
[wp] [Timeout] typed_foo036_loop_invariant_30_established (Qed 58ms) (Z3)
[wp] [Timeout] typed_foo036_loop_invariant_33_preserved (Qed 62ms) (Z3)
[wp] [Timeout] typed_foo036_loop_invariant_33_established (Qed 45ms) (Z3)
[wp] Proved goals:   72 / 79
  Qed:              61
  Alt-Ergo 2.5.4:    9
  Z3 4.8.12:         2 (30ms-980ms)
  Timeout:           7
------------------------------------------------------------
  Function foo036
------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 16):
Let x_1 = k + z.
Let x_2 = k + z - y.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(y) /\ is_sint32(y_1) /\ is_sint32(z) /\ is_sint32(1 + z) /\
      is_sint32(x_1) /\ is_sint32(x_2).
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_1) /\ (0 <= z).
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x + y_1 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y_1).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_1 <= w.
  (* Else *)
  Have: w <= x_1.
  (* Invariant *)
  Have: (z % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_1) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: (k % 2) = 0.
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_1.
  (* Invariant *)
  Have: (y % 2) = 0.
}
Prove: y < k.
Prover Z3 4.8.12 returns Timeout (Qed:54ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:54ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 16):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 17):
Prove: true.
Prover Qed returns Valid (20ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 17):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 18):
Prove: true.
Prover Qed returns Valid (25ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 18):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 19):
Prove: true.
Prover Qed returns Valid (7ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 19):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 20):
Prove: true.
Prover Qed returns Valid (7ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 20):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 21):
Prove: true.
Prover Qed returns Valid (7ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 21):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 22):
Prove: true.
Prover Qed returns Valid (7ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 22):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 23):
Let x_2 = x + y.
Let x_3 = x + y - y_1.
Assume {
  Type: is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(y) /\ is_sint32(y_1) /\ is_sint32(y_2) /\
      is_sint32(z) /\ is_sint32(1 + z) /\ is_sint32(x_2) /\
      is_sint32(1 + x + y) /\ is_sint32(x_3) /\ is_sint32(x + y - z).
  (* Goal *)
  When: (z < i) /\ (i <= x_2).
  (* Invariant *)
  Have: z <= x_1.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((i_1 < w) -> ((z <= i_1) ->
      ((1 + x_1 + y_2 + i_1) = w))).
  (* Invariant *)
  Have: forall i_1 : Z. ((0 <= i_1) -> ((i_1 < z) -> (i_1 < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: z <= x_2.
  (* Invariant *)
  Have: x_2 <= w.
  (* Else *)
  Have: w <= x_2.
  If (z % 2) = 1
  Then { Have: (1 + y_1 + z) = x_2. }
  Else { Have: (y_1 + z) = x_2. }
  (* Invariant *)
  Have: (y_1 + z) <= x_2.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((z <= i_1) -> ((i_1 < x_2) -> (i_1 = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_2.
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: z < x.
  (* Invariant *)
  Have: (-1) <= z.
}
Prove: i = 0.
Prover Z3 4.8.12 returns Timeout (Qed:71ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:71ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 23):
Prove: true.
Prover Qed returns Valid (0.95ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 24):
Let x_2 = x + y.
Let x_3 = x + y - y_1.
Assume {
  Type: is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(y) /\ is_sint32(y_1) /\ is_sint32(y_2) /\
      is_sint32(z) /\ is_sint32(1 + z) /\ is_sint32(x_2) /\
      is_sint32(1 + x + y) /\ is_sint32(x_3) /\ is_sint32(x + y - z).
  (* Goal *)
  When: (z < i) /\ (i <= x_2).
  (* Invariant *)
  Have: z <= x_1.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((i_1 < w) -> ((z <= i_1) ->
      ((1 + x_1 + y_2 + i_1) = w))).
  (* Invariant *)
  Have: forall i_1 : Z. ((0 <= i_1) -> ((i_1 < z) -> (i_1 < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: z <= x_2.
  (* Invariant *)
  Have: x_2 <= w.
  (* Else *)
  Have: w <= x_2.
  If (z % 2) = 1
  Then { Have: (1 + y_1 + z) = x_2. }
  Else { Have: (y_1 + z) = x_2. }
  (* Invariant *)
  Have: (y_1 + z) <= x_2.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((z <= i_1) -> ((i_1 < x_2) -> (i_1 = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_2.
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: z < x.
  (* Invariant *)
  Have: (-1) <= z.
  (* Invariant *)
  Have: forall i_1 : Z. ((z < i_1) -> ((i_1 <= x_2) -> (i_1 = 0))).
}
Prove: i = 0.
Prover Z3 4.8.12 returns Timeout (Qed:75ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:75ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 24):
Prove: true.
Prover Qed returns Valid (0.79ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 25):
Let x_1 = k + z.
Let x_2 = k + z - y.
Let x_3 = k + z - y_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(y) /\ is_sint32(y_1) /\ is_sint32(y_2) /\ is_sint32(z) /\
      is_sint32(1 + z) /\ is_sint32(x_1) /\ is_sint32(1 + k + z) /\
      is_sint32(x_2) /\ is_sint32(x_3).
  (* Goal *)
  When: (0 <= i) /\ (i <= z).
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((i_1 < w) -> ((z <= i_1) ->
      ((1 + x + y_2 + i_1) = w))).
  (* Invariant *)
  Have: forall i_1 : Z. ((0 <= i_1) -> ((i_1 < z) -> (i_1 < w))).
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_1 <= w.
  (* Else *)
  Have: w <= x_1.
  If (z % 2) = 1
  Then { Have: (1 + y_1) = k. }
  Else { Have: y_1 = k. }
  (* Invariant *)
  Have: y_1 <= k.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((z <= i_1) -> ((i_1 < x_1) -> (i_1 = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_1.
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_1.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: y < k.
  (* Invariant *)
  Have: (-1) <= z.
  (* Invariant *)
  Have: forall i_1 : Z. ((z < i_1) -> ((i_1 <= x_1) -> (i_1 = 0))).
}
Prove: i <= x_1.
Prover Alt-Ergo 2.5.4 returns Valid (Qed:68ms) (6ms) (49)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 25):
Prove: true.
Prover Qed returns Valid (0.59ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 26):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 26):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 27):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 27):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 28):
Prove: true.
Prover Qed returns Valid (9ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 28):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 29):
Prove: true.
Prover Qed returns Valid (7ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 29):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 30):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 30):
Prove: true.
Prover Qed returns Valid (1ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 31):
Let x_1 = k + z.
Let x_2 = k + z - y.
Let x_3 = k + z - y_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(y) /\ is_sint32(y_1) /\ is_sint32(y_2) /\ is_sint32(z) /\
      is_sint32(1 + z) /\ is_sint32(x_1) /\ is_sint32(1 + k + z) /\
      is_sint32(x_2) /\ is_sint32(x_3).
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_1 <= w.
  (* Else *)
  Have: w <= x_1.
  If (z % 2) = 1
  Then { Have: (1 + y_1) = k. }
  Else { Have: y_1 = k. }
  (* Invariant *)
  Have: y_1 <= k.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_1) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_1.
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_1.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: y < k.
  (* Invariant *)
  Have: (-1) <= z.
  (* Invariant *)
  Have: forall i : Z. ((z < i) -> ((i <= x_1) -> (i = 0))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i <= z) -> (i <= x_1))).
}
Prove: (-1) <= x_1.
Prover Z3 4.8.12 returns Valid (Qed:64ms) (10ms) (38586)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:64ms) (35)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 31):
Prove: true.
Prover Qed returns Valid (2ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 32):
Prove: true.
Prover Qed returns Valid (11ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 32):
Prove: true.
Prover Qed returns Valid (2ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 46):
Prove: true.
Prover Qed returns Valid (10ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 46):
Prove: true.
Prover Qed returns Valid (4ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 47):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 47):
Prove: true.
Prover Qed returns Valid (4ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 48):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 48):
Prove: true.
Prover Qed returns Valid (4ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 49):
Prove: true.
Prover Qed returns Valid (6ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 49):
Prove: true.
Prover Qed returns Valid (4ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 50):
Prove: true.
Prover Qed returns Valid (6ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 50):
Prove: true.
Prover Qed returns Valid (4ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 51):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 51):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 52):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 52):
Prove: true.
Prover Qed returns Valid (4ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 71):
Let x_1 = k + z.
Let x_2 = -y.
Let x_3 = k + z - y.
Let x_4 = k + z - y_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\
      is_sint32(w) /\ is_sint32(x) /\ is_sint32(y_1) /\ is_sint32(y) /\
      is_sint32(y_2) /\ is_sint32(z) /\ is_sint32(x_1) /\ is_sint32(x_4) /\
      is_sint32(x_3) /\ is_sint32(2 + k + z - y).
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_1 <= w.
  (* Else *)
  Have: w <= x_1.
  If (z % 2) = 1
  Then { Have: (1 + y_1) = k. }
  Else { Have: y_1 = k. }
  (* Invariant *)
  Have: y_1 <= k.
  (* Invariant *)
  Have: (x_4 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_1) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_1.
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_1.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
}
Prove: y <= (2 + k).
Prover Z3 4.8.12 returns Valid (Qed:72ms) (10ms) (37302)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:72ms) (36)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 71):
Prove: true.
Prover Qed returns Valid (17ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 72):
Prove: true.
Prover Qed returns Valid (7ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 72):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 73):
Prove: true.
Prover Qed returns Valid (18ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 73):
Prove: true.
Prover Qed returns Valid (6ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 74):
Let x_1 = k + z.
Let x_2 = -y.
Let x_3 = k + z - y.
Let x_4 = k + z - y_1.
Let x_5 = 2 + k + z - y.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\
      is_sint32(w) /\ is_sint32(x) /\ is_sint32(y_1) /\ is_sint32(y) /\
      is_sint32(y_2) /\ is_sint32(z) /\ is_sint32(y - 2) /\ is_sint32(x_1) /\
      is_sint32(x_4) /\ is_sint32(x_3) /\ is_sint32(x_5).
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_1 <= w.
  (* Else *)
  Have: w <= x_1.
  If (z % 2) = 1
  Then { Have: (1 + y_1) = k. }
  Else { Have: y_1 = k. }
  (* Invariant *)
  Have: y_1 <= k.
  (* Invariant *)
  Have: (x_4 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_1) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_1.
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_1.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: y <= (2 + k).
}
Prove: (x_5 % 2) = 0.
Prover Z3 4.8.12 returns Valid (Qed:61ms) (110ms) (398630)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:61ms) (37ms) (542)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 74):
Let x_3 = k + x_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(x_2) /\ is_sint32(y) /\ is_sint32(y_1) /\
      is_sint32(y_2) /\ is_sint32(x_3).
  (* Invariant *)
  Have: x_1 <= x_2.
  (* Invariant *)
  Have: x_1 <= w.
  (* Invariant *)
  Have: (0 <= x_1) /\ (0 <= y_2).
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((x_1 <= i) -> ((1 + x_2 + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < x_1) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: 0 <= (x_2 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (x_1 % 2) = 1
  Then { Have: (y_1 = k) /\ ((1 + y) = y_1). Have: (1 + x_1) = x. }
  Else { Have: (x_1 = x) /\ (y = k). }
  (* Invariant *)
  Have: x_1 <= x.
}
Prove: (x % 2) = 0.
Prover Z3 4.8.12 returns Valid (Qed:43ms) (10ms) (40631)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:43ms) (20ms) (301)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 75):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 75):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 76):
Let x_2 = 2 + x.
Let x_3 = x + y_1.
Let x_4 = x + y_1 - y.
Assume {
  Type: is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\
      is_sint32(x) /\ is_sint32(x_1) /\ is_sint32(y) /\ is_sint32(y_1) /\
      is_sint32(y_2) /\ is_sint32(z) /\ is_sint32(y_1 - 2) /\
      is_sint32(x_2) /\ is_sint32(x_3) /\ is_sint32(x_4) /\
      is_sint32(x + y_1 - z).
  (* Goal *)
  When: (i < w) /\ (z <= i).
  (* Invariant *)
  Have: z <= x_1.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((i_1 < w) -> ((z <= i_1) ->
      ((1 + x_1 + y_2 + i_1) = w))).
  (* Invariant *)
  Have: forall i_1 : Z. ((0 <= i_1) -> ((i_1 < z) -> (i_1 < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: z <= x_3.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (z % 2) = 1
  Then { Have: (1 + y + z) = x_3. }
  Else { Have: (y + z) = x_3. }
  (* Invariant *)
  Have: (y + z) <= x_3.
  (* Invariant *)
  Have: (x_4 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((z <= i_1) -> ((i_1 < x_3) -> (i_1 = (-1)))).
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_3.
  (* Invariant *)
  Have: 0 <= x_3.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: y_1 <= y.
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: z <= x_2.
  (* Invariant *)
  Have: (x_2 % 2) = 0.
}
Prove: i = (-1).
Prover Z3 4.8.12 returns Timeout (Qed:63ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:63ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 76):
Let x_3 = k + x_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(x_2) /\ is_sint32(y) /\ is_sint32(y_1) /\
      is_sint32(y_2) /\ is_sint32(x_3).
  (* Goal *)
  When: (i < w) /\ (x_1 <= i).
  (* Invariant *)
  Have: x_1 <= x_2.
  (* Invariant *)
  Have: x_1 <= w.
  (* Invariant *)
  Have: (0 <= x_1) /\ (0 <= y_2).
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: forall i_1 : Z. ((i_1 < w) -> ((x_1 <= i_1) ->
      ((1 + x_2 + y_2 + i_1) = w))).
  (* Invariant *)
  Have: forall i_1 : Z. ((0 <= i_1) -> ((i_1 < x_1) -> (i_1 < w))).
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: 0 <= (x_2 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (x_1 % 2) = 1
  Then { Have: (y_1 = k) /\ ((1 + y) = y_1). Have: (1 + x_1) = x. }
  Else { Have: (x_1 = x) /\ (y = k). }
  (* Invariant *)
  Have: x_1 <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
}
Prove: (1 + i + x + y) = x_3.
Prover Z3 4.8.12 returns Timeout (Qed:58ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:58ms) (8s)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 77):
Let x_2 = 2 + x.
Let x_3 = -x.
Let x_4 = y + z - x.
Let x_5 = y + z.
Let x_6 = y - 1.
Let x_7 = 1 + z.
Assume {
  Type: is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\
      is_sint32(x) /\ is_sint32(x_1) /\ is_sint32(y) /\ is_sint32(y_1) /\
      is_sint32(z) /\ is_sint32(x_6) /\ is_sint32(x_7) /\ is_sint32(x_2) /\
      is_sint32(x_5) /\ is_sint32(x_4) /\ is_sint32(y + z - 2 - x).
  (* Residual *)
  When: (z % 2) = 1.
  (* Invariant *)
  Have: z <= x_1.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_1) /\ (0 <= z).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x_1 + y_1 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_1).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: x_5 <= w.
  (* Else *)
  Have: w <= x_5.
  (* Invariant *)
  Have: (x_7 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_5) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 < y.
  (* Invariant *)
  Have: (-1) <= z.
  (* Invariant *)
  Have: 0 <= x_5.
  (* Invariant *)
  Have: (x_6 % 2) = 0.
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: z < x.
  (* Invariant *)
  Have: x <= x_5.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: (x_4 % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: z <= x_2.
  (* Invariant *)
  Have: (x_2 % 2) = 0.
}
Prove: z <= (1 + x).
Prover Alt-Ergo 2.5.4 returns Valid (Qed:68ms) (5ms) (40)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 77):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 78):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 78):
Prove: true.
Prover Qed returns Valid (5ms)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 79):
Let x_2 = k + z.
Let x_3 = 2 + x.
Let x_4 = -x.
Let x_5 = k + z - x.
Let x_6 = k + z - y.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\
      is_sint32(w) /\ is_sint32(x) /\ is_sint32(x_1) /\ is_sint32(y) /\
      is_sint32(y_1) /\ is_sint32(z) /\ is_sint32(x_3) /\ is_sint32(x_2) /\
      is_sint32(x_5) /\ is_sint32(x_6) /\ is_sint32(k + z - 2 - x).
  (* Invariant *)
  Have: z <= x_1.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_1) /\ (0 <= z).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x_1 + y_1 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_1).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_2 <= w.
  (* Else *)
  Have: w <= x_2.
  If (z % 2) = 1
  Then { Have: (1 + y) = k. }
  Else { Have: y = k. }
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_6 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_2) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_2.
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: x_2 <= (x + y).
  (* Invariant *)
  Have: x <= x_2.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: (x_5 % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: z <= x_3.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: x_2 <= (2 + x + y).
}
Prove: x_3 <= x_2.
Prover Z3 4.8.12 returns Timeout (Qed:62ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:62ms) (8s)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 79):
Let x_2 = k + x.
Let x_3 = 1 + x.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(y) /\ is_sint32(k - 1) /\ is_sint32(x_3) /\
      is_sint32(x_2).
  (* Residual *)
  When: (x % 2) = 1.
  (* Invariant *)
  Have: x <= x_1.
  (* Invariant *)
  Have: x <= w.
  (* Invariant *)
  Have: (0 <= x) /\ (0 <= y).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((x <= i) -> ((1 + x_1 + y + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < x) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_2 <= w.
  (* Else *)
  Have: w <= x_2.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((x <= i) -> ((i < x_2) -> (i = (-1)))).
}
Prove: 0 < k.
Prover Z3 4.8.12 returns Timeout (Qed:45ms) (8s)
Prover Alt-Ergo 2.5.4 returns Timeout (Qed:45ms) (8s)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 80):
Let x_1 = -y.
Let x_2 = 2 + k + z - y.
Let x_3 = k + z.
Let x_4 = k + z - y.
Let x_5 = k + z - y_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\
      is_sint32(w) /\ is_sint32(x) /\ is_sint32(y_1) /\ is_sint32(y) /\
      is_sint32(y_2) /\ is_sint32(z) /\ is_sint32(y - 2) /\ is_sint32(x_3) /\
      is_sint32(x_5) /\ is_sint32(x_4) /\ is_sint32(x_2).
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_2) /\ (0 <= z).
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (z % 2) = 1
  Then { Have: (1 + y_1) = k. }
  Else { Have: y_1 = k. }
  (* Invariant *)
  Have: y_1 <= k.
  (* Invariant *)
  Have: (x_5 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_3) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y_1.
  (* Invariant *)
  Have: y_1 <= x_3.
  (* Invariant *)
  Have: 0 <= x_3.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_4 % 2) = 0.
  (* Invariant *)
  Have: y <= y_1.
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_3.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: y <= (2 + k).
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: y <= (2 + y_1).
  (* Invariant *)
  Have: 2 <= y.
}
Prove: y <= (2 + k + z).
Prover Z3 4.8.12 returns Valid (Qed:61ms) (10ms) (38048)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:61ms) (6ms) (40)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 80):
Let x_2 = x + y.
Let x_3 = 1 + x.
Let x_4 = 1 + x + y.
Assume {
  Type: is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(y) /\ is_sint32(y_1) /\ is_sint32(x_3) /\
      is_sint32(1 + y) /\ is_sint32(x_4).
  (* Residual *)
  When: (x % 2) = 1.
  (* Invariant *)
  Have: x <= x_1.
  (* Invariant *)
  Have: x <= w.
  (* Invariant *)
  Have: (0 <= x) /\ (0 <= y_1).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((x <= i) -> ((1 + x_1 + y_1 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < x) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_1).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: (-1) <= y.
  (* Invariant *)
  Have: x_2 < w.
  (* Else *)
  Have: w <= x_4.
  (* Invariant *)
  Have: (x_3 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((x <= i) -> ((i <= x_2) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y.
}
Prove: (-1) <= x.
Prover Z3 4.8.12 returns Valid (Qed:41ms) (10ms) (34739)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:41ms) (5ms) (26)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 81):
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 81):
Let x_3 = k + x_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(x_2) /\ is_sint32(y) /\ is_sint32(y_1) /\
      is_sint32(y_2) /\ is_sint32(x_3).
  (* Invariant *)
  Have: x_1 <= x_2.
  (* Invariant *)
  Have: x_1 <= w.
  (* Invariant *)
  Have: (0 <= x_1) /\ (0 <= y_2).
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((x_1 <= i) -> ((1 + x_2 + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < x_1) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: 0 <= (x_2 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (x_1 % 2) = 1
  Then { Have: (y_1 = k) /\ ((1 + y) = y_1). Have: (1 + x_1) = x. }
  Else { Have: (x_1 = x) /\ (y = k). }
  (* Invariant *)
  Have: x_1 <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((x_1 <= i) -> ((i < x_3) -> ((1 + x + y + i) = x_3))).
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: 0 <= x.
}
Prove: 0 <= (x + y).
Prover Z3 4.8.12 returns Valid (Qed:47ms) (10ms) (36041)
Prover Alt-Ergo 2.5.4 returns Valid (Qed:47ms) (5ms) (35)

------------------------------------------------------------

Goal Preservation of Invariant (file out/036_0011/036_merged.c, line 82):
Let x_2 = 2 + x.
Let x_3 = k + z.
Let x_4 = -x.
Let x_5 = k + z - x.
Let x_6 = k + z - y.
Let x_7 = k + z - 2 - x.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0) /\ is_sint32(tmp_0_0) /\
      is_sint32(w) /\ is_sint32(x) /\ is_sint32(x_1) /\ is_sint32(y) /\
      is_sint32(y_1) /\ is_sint32(z) /\ is_sint32(x_2) /\ is_sint32(x_3) /\
      is_sint32(x_5) /\ is_sint32(x_6) /\ is_sint32(x_7).
  (* Invariant *)
  Have: z <= x_1.
  (* Invariant *)
  Have: z <= w.
  (* Invariant *)
  Have: (0 <= y_1) /\ (0 <= z).
  (* Invariant *)
  Have: (x_1 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((z <= i) -> ((1 + x_1 + y_1 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < z) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_1.
  (* Invariant *)
  Have: 0 <= (x_1 + y_1).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_1 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (z % 2) = 1
  Then { Have: (1 + y) = k. }
  Else { Have: y = k. }
  (* Invariant *)
  Have: y <= k.
  (* Invariant *)
  Have: (x_6 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((z <= i) -> ((i < x_3) -> (i = (-1)))).
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: y <= x_3.
  (* Invariant *)
  Have: 0 <= x_3.
  (* Invariant *)
  Have: (y % 2) = 0.
  (* Invariant *)
  Have: z <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: x_3 <= (x + y).
  (* Invariant *)
  Have: x <= x_3.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: (x_5 % 2) = 0.
  (* Then *)
  Have: tmp_0 != 0.
  (* Invariant *)
  Have: z <= x_2.
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: x_3 <= (2 + x + y).
  (* Invariant *)
  Have: x_2 <= x_3.
  (* Invariant *)
  Have: (-2) <= x.
}
Prove: (x_7 % 2) = 0.
Prover Z3 4.8.12 returns Valid (Qed:73ms) (30ms) (103459)

------------------------------------------------------------

Goal Establishment of Invariant (file out/036_0011/036_merged.c, line 82):
Let x_3 = k + x_1.
Assume {
  Type: is_sint32(k) /\ is_sint32(tmp_0_0) /\ is_sint32(w) /\ is_sint32(x) /\
      is_sint32(x_1) /\ is_sint32(x_2) /\ is_sint32(y) /\ is_sint32(y_1) /\
      is_sint32(y_2) /\ is_sint32(x_3).
  (* Invariant *)
  Have: x_1 <= x_2.
  (* Invariant *)
  Have: x_1 <= w.
  (* Invariant *)
  Have: (0 <= x_1) /\ (0 <= y_2).
  (* Invariant *)
  Have: (x_2 % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((i < w) -> ((x_1 <= i) -> ((1 + x_2 + y_2 + i) = w))).
  (* Invariant *)
  Have: forall i : Z. ((0 <= i) -> ((i < x_1) -> (i < w))).
  (* Invariant *)
  Have: 0 <= x_2.
  (* Invariant *)
  Have: 0 <= (x_2 + y_2).
  (* Invariant *)
  Have: 0 <= w.
  (* Invariant *)
  Have: (y_2 % 2) = 0.
  (* Then *)
  Have: tmp_0_0 != 0.
  (* Invariant *)
  Have: 0 <= k.
  (* Invariant *)
  Have: x_3 <= w.
  (* Else *)
  Have: w <= x_3.
  If (x_1 % 2) = 1
  Then { Have: (y_1 = k) /\ ((1 + y) = y_1). Have: (1 + x_1) = x. }
  Else { Have: (x_1 = x) /\ (y = k). }
  (* Invariant *)
  Have: x_1 <= x.
  (* Invariant *)
  Have: (x % 2) = 0.
  (* Invariant *)
  Have: forall i : Z. ((x_1 <= i) -> ((i < x_3) -> ((1 + x + y + i) = x_3))).
  (* Invariant *)
  Have: 0 <= y.
  (* Invariant *)
  Have: 0 <= x.
  (* Invariant *)
  Have: 0 <= (x + y).
}
Prove: (y % 2) = 0.
Prover Z3 4.8.12 returns Valid (Qed:50ms) (980ms) (3339263)

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 33) (1/4):
Prove: true.
Prover Qed returns Valid

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 33) (2/4):
Call Result at line 41
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 33) (3/4):
Effect at line 56
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 33) (4/4):
Call Result at line 86
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 53):
Prove: true.
Prover Qed returns Valid

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 83) (1/2):
Prove: true.
Prover Qed returns Valid

------------------------------------------------------------

Goal Loop assigns (file out/036_0011/036_merged.c, line 83) (2/2):
Call Result at line 86
Prove: true.
Prover Qed returns Valid (8ms)

------------------------------------------------------------
[wp:pedantic-assigns] out/036_0011/036_merged.c:1: Warning: 
  No 'assigns' specification for function 'unknown1'.
  Callers assumptions might be imprecise.
[wp:pedantic-assigns] out/036_0011/036_merged.c:2: Warning: 
  No 'assigns' specification for function 'unknown2'.
  Callers assumptions might be imprecise.
[wp:pedantic-assigns] out/036_0011/036_merged.c:3: Warning: 
  No 'assigns' specification for function 'unknown3'.
  Callers assumptions might be imprecise.
[wp:pedantic-assigns] out/036_0011/036_merged.c:5: Warning: 
  No 'assigns' specification for function 'foo036'.
  Callers assumptions might be imprecise.
